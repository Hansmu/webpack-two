Single page app
A bare-bones HTML file gets sent to the user. Javascript then runs on the user machine to create a full webpage.
We rely on a bunch of Javascript code.

In a SPA we have a ton of Javascript code. In server side rendering/templating there isn't nearly as much JS code.

When you split up your JS codebase into several files(modules), it increases its readability. This, however, has downsides.
Problems that arise:
1) Load order. Some files rely on other files. If it gets loaded in the wrong order, then it all collapses. Load order should be the same every time.
2) More files, slower load times. Downloading dozens of Javascript files cause performance issues. Especially on mobile devices.

Webpack handles these problems by taking all of our JS files and merge them into one large JS file, while making sure execution order is correct for the files.
This is Webpack's primary purpose.

Javascript has several module systems. To name some:
CommonJS (used in NodeJS): Uses 'require', 'module.exports'
AMD (used in frontend): Uses 'require', 'define'
ES2015: Uses 'import', 'export'

Webpack automatically searches for webpack.config.js file.
Specifying entry point for Webpack tells it what to execute first when our application starts up in the browser.
Have to use double quotes in scripts. Should run the local copy inside node_modules. Helps to handle juggling versions between projects.

Webpack takes all of our modules code. Puts them into individual functions, puts them into an array and calls the individual functions from the array.

Module loaders are used to do some pre-processing on them. Often used to transpile to ES5 code. Babel used for that.

For Babel you need 3 modules.
babel-loader: teaches Babel how to work with Webpack. Compatibility layer.
babel-core: knows how to take in code, parse it and generate some output files. Heart of Babel. Doesn't actually know how to change code, need rulesets for that.
babel-preset-env: ruleset for telling Babel exactly what pieces of ES2015/6/7 syntax to look for and how to turn it into ES5 code.
.babelrc tells babel-core what ruleset to check for.

With loaders it makes sense to only apply it to certain files as otherwise errors might arise.

Letting Webpack handle our CSS means we can make use of a bunch of different CSS files. Can import the CSS files to each of the files we care about them in.
css-loader: knows how to deal with CSS imports.
style-loader: takes CSS imports and adds them to the HTML document.
Takes our styles as raw text and injects it into our bundle.js. Then manually puts it into the html file using JS.